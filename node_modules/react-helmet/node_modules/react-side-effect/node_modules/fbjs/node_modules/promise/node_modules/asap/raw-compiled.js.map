{"version":3,"sources":["raw.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;AAEb,IAAI,MAAM,CAAC;AACX,IAAI,eAAe,GAAG,OAAO,YAAY,KAAK,UAAU,CAAC;;;;;;;;;;;AAWzD,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;AACzB,SAAS,OAAO,CAAC,IAAI,EAAE;AACnB,QAAI,CAAC,KAAK,CAAC,MAAM,EAAE;AACf,oBAAY,EAAE,CAAC;AACf,gBAAQ,GAAG,IAAI,CAAC;KACnB;;AAED,SAAK,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;CAC9B;;AAED,IAAI,KAAK,GAAG,EAAE,CAAC;;;AAGf,IAAI,QAAQ,GAAG,KAAK,CAAC;;;;AAIrB,IAAI,KAAK,GAAG,CAAC,CAAC;;;;AAId,IAAI,QAAQ,GAAG,IAAI,CAAC;;;;;;;;AAQpB,SAAS,KAAK,GAAG;AACb,WAAO,KAAK,GAAG,KAAK,CAAC,MAAM,EAAE;AACzB,YAAI,YAAY,GAAG,KAAK,CAAC;;;AAGzB,aAAK,GAAG,KAAK,GAAG,CAAC,CAAC;AAClB,aAAK,CAAC,YAAY,CAAC,CAAC,IAAI,EAAE,CAAC;;;;;;AAM3B,YAAI,KAAK,GAAG,QAAQ,EAAE;;;AAGlB,iBAAK,IAAI,IAAI,GAAG,CAAC,EAAE,SAAS,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,EAAE,IAAI,GAAG,SAAS,EAAE,IAAI,EAAE,EAAE;AAC3E,qBAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;aACrC;AACD,iBAAK,CAAC,MAAM,IAAI,KAAK,CAAC;AACtB,iBAAK,GAAG,CAAC,CAAC;SACb;KACJ;AACD,SAAK,CAAC,MAAM,GAAG,CAAC,CAAC;AACjB,SAAK,GAAG,CAAC,CAAC;AACV,YAAQ,GAAG,KAAK,CAAC;CACpB;;AAED,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC;AACpC,SAAS,YAAY,GAAG;;;;AAIpB,QAAI,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC;AAClC,QAAI,YAAY,EAAE;AACd,YAAI,CAAC,MAAM,EAAE;;;AAGT,kBAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;SAC9B;AACD,cAAM,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;KACzC;;;;;;;;AAQD,QAAI,QAAQ,IAAI,eAAe,EAAE;AAC7B,oBAAY,CAAC,KAAK,CAAC,CAAC;KACvB,MAAM;AACH,eAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;KAC3B;;AAED,QAAI,YAAY,EAAE;AACd,cAAM,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,GAAG,YAAY,CAAC;KACjD;CACJ","file":"raw-compiled.js","sourcesContent":["\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n"]}