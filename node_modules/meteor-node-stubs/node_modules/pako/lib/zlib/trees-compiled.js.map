{"version":3,"sources":["trees.js"],"names":[],"mappings":"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","file":"trees-compiled.js","sourcesContent":["'use strict';\n\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2*L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES+2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nvar StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n};\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nvar TreeDesc = function(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n};\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short (s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max+1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n*2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n-base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length-1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits+1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m*2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;\n        tree[m*2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits-1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n*2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS+1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES-1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1<<extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length-1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0 ; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1<<extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n*2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n*2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n*2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n*2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES+1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n*2 + 1]/*.Len*/ = 5;\n    static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n*2;\n  var _m2 = m*2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code+LITERALS+1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n*2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node*2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n+1)*2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6*2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10*2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138*2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n+1)*2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count-3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count-3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count-11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3*(max_blindex+1) + 5+5+4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes-1,   5);\n  send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES<<1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len+3+7) >>> 3;\n    static_lenb = (s.static_len+3+7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc*2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize-1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n"]}