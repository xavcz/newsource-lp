{"version":3,"sources":["inffast.js"],"names":[],"mappings":"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","file":"inffast-compiled.js","sourcesContent":["'use strict';\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n"]}